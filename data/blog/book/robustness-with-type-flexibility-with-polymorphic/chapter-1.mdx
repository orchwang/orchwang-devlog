---
title: 타입으로 견고하게, 다형성으로 유연하게-홍재민 Chapter 1
date: '2023-12-20'
tags: ['book', 'type', 'polymorphic']
draft: true
summary: 
images: []
---

# TL;DR

독서에 앞서 서론을 정리했던 [포스트](https://blog.orchwang.dev/blog/book/robustness-with-type-flexibility-with-polymorphic/summary) 에서 내가 계획한것 처럼 챕터별로 읽은 내용을 정리하고 내것으로 만들어 보려 한다.

# Chapter 1. 타입 검사 훑어보기

## 1.1 타입 검사의 정의와 필요성

### 불편해도 쓰는 이유

- 버그 수정보다 어려운 버그 찾기. 버그의 가장 흔한 오류인 타입 오류. 
- 이는 프로그램을 멈추게 할 정도로 파급력이 크다.
- 프로그램을 실행해 봐서 버그를 찾아볼 수 있지만 모든 상황을 실험해보기에는 너무 오래 걸린다.
- 그래서 사용하는 것이 바로 `Type Checker(타입 검사기)`
- 하지만 Alan Turing 에 의해 증명된 바 이상적인 Type Checker 는 만드는 것이 불가능하다.
  > 주어진 프로그램이 언젠가 정지 하는지, 영원히 작동하는지 알수 없다는 것을 증명함. 이에 이상적인 Type Checker 가 없다는 것도 증명된 셈
- 현실적인 Type Checker 는 타입 오류가 없는 모든 경우의 수를 테스트 할 수는 없지만, 적어도 타입 오류가 있는 경우는 100% 걸러낼 수 있다.
- 실제 Type Checker 는 타입 오류가 없지만 있다고 할 수 있는데 이때는 개발자가 오류 메시지 등으로 쉽게 조정이 가능한 경우가 대부분.
  - 정말 있으면 -> 버그를 없애기 위한 코드 수정
  - 사실 없었으면 -> Type Checker 를 돕기 위해 코드 수정

## 1.2 정적 타입 언어

- Type Checker 는 보통 언어 제작자가 만든다.
- Java, C, C++, C#, TypeScript, Go, Kotlin, Rust 등은 정적 타입 언어(Statically typed language) 로 Type Checker 를 제공한다.
- `Statically` 는 정적이라는 뜻으로 `프로그램을 실행하기 전` 을 의미한다고 한다. (?) 프로그램 시작 전 Type Checking 을 한다는 의미.
- 반대로 Type Checking 을 통과하지 못하면 프로그램 실행을 막게 됨.
- Python, Ruby, LISP 등은 Type Checker 를 지원하지 않는다. 이는 동적 타입 언어(dynamically typed language) 라고 불리운다.
- 위 언어들은 프로그램 실행 중에 Type Checking 결과를 알 수 있다.

## 1.3 타입 검사의 원리

- Type Checker 는 문제가 있을 경우 오류 메시지를 출력하며 우리는 이를 이해할 수 있어야 한다.
- Type Checker 의 작동 원리를 알면 오류를 이해하기 좋다.
- Type Checking 을 자동자 공장에 비유하면 아래와 같다.
  1. 기본 부품 검사
  2. 복합 부품 검사 (이때 기본 부품 단계에서 얻은 정보를 활용한다. 휠과 타이어의 규격이 맞아야 한다 같은 정보.)
  3. 1, 2 를 반복해 더 복잡한 부품을 완성해 간다.
- 이를 코드로 적용해보면 아래와 같다.
  1. 아래의 함수를 검사한다고 생각하자.
    ```
    printInt(5 + 7)
    ```
  2. 우선 부품에 해당하는 5, 7 이 정수임을 확인한다.
  3. 이어 5 + 7 의 결과가 정수임을 확인한다.
  4. 검사 완료!
    ```
    printInt 의 인자는 정수
    5 + 7 은 정수
    ```

### 리터럴

Type Checker 는 어떻게 각 부품을 구체적으로 검사할까? 가장 쉬운 경우는 정수 리터럴을 검사하는 경우라고 한다. 

여기서 잠깐! 리터럴은 무엇일까? 프로그래밍 언어에서 값 자체를 나타내는 표기법 또는 표현이다. 리터럴은 데이터를 나타내는 고정된 값을 의미하며, 변수나 상수와 달리 값을 직접 나타낸다. 다양한 리터럴이 있지만 위 `printInt` 함수 설명을 위해 `정수 리터럴` 을 예로 든다.

- 정수 리터럴의 계산 결과는 항상 정수 (라는 법칙을 찾아냄)

### 덧셈

정수 리터럴을 체크 했으니 이제 덧셈을 검사해볼 차례 이다.

- 작은 부품에서 큰 부품으로 원칙에 따라 정수 리터럴 검사 후 덧셈 검사를 진행한다.

### 삼항 연산자

`a ? b : c` 형태의 부품이 삼항 연산다 이다. Python 기준 `b if a else c` 가 되겠다.

1. a, b, c 의 type 을 검사한다. a: boolean, b, c 는 별도 조건 없음
2. 하지만 결과를 내려면 b, c 의 type 도 정해져야 한다.
3. `(nthPrime(999999999) % 10 == 7) ? 1 : false` 라는 부품이 주어졌다면?
4. a가 true, false 중 어느쪽인지 알아내려면 9억9999만9999번째 소수를 찾아야 한다. 엄청 오래 걸리겠지?
5. 따라서 삼항 연산자 검사 에서는 a 의 결과를 고려하지 않는다.

### 변수

리터럴, 덧셈, 삼항 연산자는 개발자가 따로 정의하지 않고도 사용 가능한 것이다. 하지만 변수나 함수는 직접 정의해야 사용 가능하다.

- 변수는 정의하면 그것이 하나의 부품
- 변수는 다른 부품을 구성하는 데 사용 가능
- 변수에 type 을 함께 정의하는 방식 사용하기도 함.
  ```
  Int res;
  ```

### 함수

- f(a) 형태
- 호출할 함수의 이름, 함수에 넘길 인자 로 구성
- `Boolean isPositive(Int num) { return num > 0; }` 이라는 함수를 검증하려면?
  1. `isPositive(1)` 을 검사하는 상황
  2. 인자 1 이 Int 인지 검사
  3. 결과 타입이 Boolean 인지 검사

- Golang 을 통해 함수의 type checking 전반을 살펴본다.
  ```go
  var res int
  res = 3
  func isPositive(num int) bool { return num > 0 }
  isPositive(1)
  func printString(str string) { ... }
  printString("2")
  func add(num1 int, num2 int) int { return num1 + num2 }
  add(1, 2)
  ```

## 1.4 타입 검사 결과의 활용

## 1.5 타입 추론

## 1.6 더 세밀한 타입

## 1.7 정적 타입 언어의 장단점

## 1.8 다형성

# 정리
